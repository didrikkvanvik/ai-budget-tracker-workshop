# Workshop Step 002: API Endpoints

## Mission ðŸŽ¯

In this step, you'll create the API endpoints that will handle transaction data - both for retrieving transactions and later for importing them. You'll build secure, paginated endpoints using .NET minimal APIs.

**Your goal**: Create working API endpoints for transaction management that support authentication, pagination, and proper error handling.

**Learning Objectives**:
- .NET minimal API development
- Authentication and authorization integration
- Pagination implementation
- API testing with HTTP files

---

## Prerequisites

Before starting, ensure you completed:
- [001-transactions.md](001-transactions.md) - Transaction model and database setup

---

## Branches

**Starting branch:** `001-transactions`
**Solution branch:** `002-api`

---

## Step 2.1: Create Paged Result Model

*First, we'll create a reusable pagination model that provides consistent paging across our APIs.*

Create `src/BudgetTracker.Api/Features/Transactions/List/PagedResult.cs`:

```csharp
namespace BudgetTracker.Api.Features.Transactions.List;

public class PagedResult<T>
{
    public List<T> Items { get; set; } = new();
    public int TotalCount { get; set; }
    public int Page { get; set; }
    public int PageSize { get; set; }
    public int TotalPages => (int)Math.Ceiling((double)TotalCount / PageSize);
    public bool HasNextPage => Page < TotalPages;
    public bool HasPreviousPage => Page > 1;
}
```

## Step 2.2: Create Transaction List Endpoint

*This endpoint retrieves transactions for the authenticated user with pagination support, sorted by date for better UX.*

Create `src/BudgetTracker.Api/Features/Transactions/List/TransactionListApi.cs`:

```csharp
using System.Security.Claims;
using BudgetTracker.Api.Auth;
using BudgetTracker.Api.Infrastructure;
using Microsoft.EntityFrameworkCore;

namespace BudgetTracker.Api.Features.Transactions.List;

public static class TransactionListApi
{
    public static IEndpointRouteBuilder MapTransactionListEndpoint(this IEndpointRouteBuilder routes)
    {
        routes.MapGet("/",
                async (BudgetTrackerContext db, ClaimsPrincipal claimsPrincipal, int page = 1, int pageSize = 20) =>
                {
                    if (page < 1) page = 1;
                    if (pageSize < 1 || pageSize > 100) pageSize = 20;

                    var query = db.Transactions.Where(t => t.UserId == claimsPrincipal.GetUserId());
                    var totalCount = await query.CountAsync();

                    var items = await query
                        .OrderByDescending(t => t.Date)
                        .ThenByDescending(t => t.ImportedAt)
                        .Skip((page - 1) * pageSize)
                        .Take(pageSize)
                        .ToListAsync();

                    var result = new PagedResult<Transaction>
                    {
                        Items = items,
                        TotalCount = totalCount,
                        Page = page,
                        PageSize = pageSize
                    };

                    return Results.Ok(result);
                });

        return routes;
    }
}
```

## Step 2.3: Create Import Result Model

*This model represents the outcome of an import operation - how many rows succeeded, failed, and what errors occurred.*

Create `src/BudgetTracker.Api/Features/Transactions/Import/ImportResult.cs`:

```csharp
namespace BudgetTracker.Api.Features.Transactions.Import;

public class ImportResult
{
    public int TotalRows { get; set; }
    public int ImportedCount { get; set; }
    public int FailedCount { get; set; }
    public List<string> Errors { get; set; } = new();
    public string? SourceFile { get; set; }
    public string? ImportSessionHash { get; set; }
    public DateTime ImportedAt { get; set; }
}
```

## Step 2.4: Create Transaction Import Endpoint Placeholder

*This endpoint will handle CSV file uploads. We'll build the basic structure now and implement the CSV parsing logic in the next step.*

Create `src/BudgetTracker.Api/Features/Transactions/Import/ImportApi.cs`:

```csharp
using System.Security.Claims;
using BudgetTracker.Api.Auth;
using BudgetTracker.Api.Infrastructure;
using Microsoft.AspNetCore.Http.HttpResults;
using Microsoft.AspNetCore.Mvc;

namespace BudgetTracker.Api.Features.Transactions.Import;

public static class ImportApi
{
    public static IEndpointRouteBuilder MapTransactionImportEndpoints(this IEndpointRouteBuilder routes)
    {
        routes.MapPost("/import", ImportAsync);

        return routes;
    }

    private static async Task<Results<Ok<ImportResult>, BadRequest<string>>> ImportAsync(
        IFormFile file, [FromForm] string account,
        BudgetTrackerContext context, ClaimsPrincipal claimsPrincipal)
    {
        var validationResult = ValidateFileInput(file, account);
        if (validationResult != null)
        {
            return validationResult;
        }

        try
        {
            var userId = claimsPrincipal.GetUserId();

            // TODO: Implement CSV parsing in next step
            // For now, return a placeholder response
            var result = new ImportResult
            {
                TotalRows = 0,
                ImportedCount = 0,
                FailedCount = 0,
                Errors = new List<string>(),
                SourceFile = file.FileName,
                ImportedAt = DateTime.UtcNow
            };

            return TypedResults.Ok(result);
        }
        catch (Exception ex)
        {
            return TypedResults.BadRequest(ex.Message);
        }
    }

    private static BadRequest<string>? ValidateFileInput(IFormFile file, string account)
    {
        if (file == null || file.Length == 0)
        {
            return TypedResults.BadRequest("No file uploaded");
        }

        if (!file.FileName.EndsWith(".csv", StringComparison.OrdinalIgnoreCase))
        {
            return TypedResults.BadRequest("Only CSV files are supported");
        }

        if (file.Length > 10 * 1024 * 1024) // 10MB limit
        {
            return TypedResults.BadRequest("File size exceeds 10MB limit");
        }

        if (string.IsNullOrWhiteSpace(account))
        {
            return TypedResults.BadRequest("Account name is required");
        }

        return null;
    }
}
```

## Step 2.5: Create Main Transaction API Registration

*This file orchestrates all transaction endpoints and registers them with the application.*

Create `src/BudgetTracker.Api/Features/Transactions/TransactionApi.cs`:

```csharp
using BudgetTracker.Api.Features.Transactions.Import;
using BudgetTracker.Api.Features.Transactions.List;

namespace BudgetTracker.Api.Features.Transactions;

public static class TransactionApi
{
    public static IEndpointRouteBuilder MapTransactionEndpoints(this IEndpointRouteBuilder routes)
    {
        var transactionsGroup = routes.MapGroup("/transactions")
            .WithTags("Transactions")
            .WithOpenApi()
            .RequireAuthorization();

        transactionsGroup
            .MapTransactionImportEndpoints()
            .MapTransactionListEndpoint();

        return routes;
    }
}
```

## Step 2.6: Apply Anti-Forgery Filter to Import Endpoint

*For file upload endpoints, we need to disable anti-forgery protection and apply the conditional filter. Update the import endpoint mapping.*

Update `src/BudgetTracker.Api/Features/Transactions/Import/ImportApi.cs`:

```csharp
using System.Security.Claims;
using BudgetTracker.Api.Auth;
using BudgetTracker.Api.Infrastructure;
using BudgetTracker.Api.AntiForgery; // Add this using
using Microsoft.AspNetCore.Http.HttpResults;
using Microsoft.AspNetCore.Mvc;

namespace BudgetTracker.Api.Features.Transactions.Import;

public static class ImportApi
{
    public static IEndpointRouteBuilder MapTransactionImportEndpoints(this IEndpointRouteBuilder routes)
    {
        routes.MapPost("/import", ImportAsync)
            .DisableAntiforgery() // Disable built-in anti-forgery
            .AddEndpointFilter<ConditionalAntiforgeryFilter>(); // Apply conditional filter

        return routes;
    }

    // ... rest of the implementation stays the same
}
```

*The `ConditionalAntiforgeryFilter` allows API key authentication (X-API-Key header) while maintaining CSRF protection for cookie-based requests.*

## Step 2.7: Register Endpoints in Program.cs

*Add the transaction endpoints to your application by updating Program.cs.*

Add to `src/BudgetTracker.Api/Program.cs` (before `app.Run()`):

```csharp
using BudgetTracker.Api.Features.Transactions;

// Add transaction endpoints
app.MapGroup("/api").MapTransactionEndpoints();
```

## Step 2.8: Configure API Key for Testing

*Before testing the API, you need to set up a valid API key and user ID for authentication.*

### Get Your User ID

First, you need to get your user ID from the database. Run this command to connect to PostgreSQL:

```bash
# Connect to PostgreSQL
docker exec -it docker-postgres-1 psql -U budgetuser -d budgettracker

# Get your user ID (look for your email or create a test user)
SELECT "Id", "Email" FROM "AspNetUsers" LIMIT 5;

# If no users exist, the Identity system will create them during login
# For testing, we'll use a predefined test user ID
```

### Configure Test API Key

Update `src/BudgetTracker.Api/appsettings.Development.json` to add your test API key:

```json
{
  "StaticApiKeys": {
    "Keys": {
      "test-key-user1": {
        "UserId": "your-actual-user-id-here",
        "Name": "Workshop Test User",
        "Description": "API key for workshop testing"
      }
    }
  }
}
```

**Replace `"your-actual-user-id-here"`** with:
- Your actual User ID from the database query above, OR
- Use `"admin@example.com"` as a placeholder for development testing

**Example with placeholder user:**
```json
{
  "StaticApiKeys": {
    "Keys": {
      "test-key-user1": {
        "UserId": "admin@example.com",
        "Name": "Workshop Test User",
        "Description": "API key for workshop testing"
      }
    }
  }
}
```

## Step 2.9: Test the API Endpoints

*Testing the API directly helps us verify the backend works before building the frontend. We use HTTP files that most editors can execute.*

Create `test-api.http` in the project root:

**Note**: The workshop includes sample CSV files in `samples/` that you can use for testing instead of creating your own data.

```http
### Test Transaction List (Empty)
GET http://localhost:5295/api/transactions
X-API-Key: test-key-user1

### Test Transaction List with Pagination
GET http://localhost:5295/api/transactions?page=1&pageSize=10
X-API-Key: test-key-user1

### Test Import Endpoint (Placeholder)
POST http://localhost:5295/api/transactions/import
X-API-Key: test-key-user1
Content-Type: multipart/form-data; boundary=WebAppBoundary

--WebAppBoundary
Content-Disposition: form-data; name="account"

Checking Account
--WebAppBoundary
Content-Disposition: form-data; name="file"; filename="generic-bank-sample.csv"
Content-Type: text/csv

< ./samples/generic-bank-sample.csv
--WebAppBoundary--
```

## Step 2.10: Verify API Functionality

1. **Start the API**:
   ```bash
   cd src/BudgetTracker.Api/
   dotnet run
   ```

2. **Test the endpoints**:
   - Use the `.http` file in VS Code with REST Client extension
   - Or use Swagger UI at `http://localhost:5295/swagger`
   - Or use curl/Postman

3. **Expected Results**:
   - GET `/api/transactions` should return empty list with pagination metadata
   - POST `/api/transactions/import` should accept the file and return placeholder response

---

## API Response Examples

### GET /api/transactions (Empty State)
```json
{
  "items": [],
  "totalCount": 0,
  "page": 1,
  "pageSize": 20,
  "totalPages": 0,
  "hasNextPage": false,
  "hasPreviousPage": false
}
```

### POST /api/transactions/import (Placeholder)
```json
{
  "totalRows": 0,
  "importedCount": 0,
  "failedCount": 0,
  "errors": [],
  "sourceFile": "sample.csv",
  "importedAt": "2024-01-15T10:30:00Z"
}
```

---

## Troubleshooting ðŸ”§

### Common Issues

1. **Authentication Errors**:
   - Ensure you're using the correct API key: `test-key-user1`
   - Verify the API key is configured in `appsettings.Development.json`
   - Check that the `UserId` in the API key configuration is valid
   - Confirm authentication is configured in `Program.cs`

2. **Anti-Forgery Token Errors**:
   - Ensure `ConditionalAntiforgeryFilter` is properly registered
   - Verify the filter is applied to the API endpoints
   - Check that `X-API-Key` header is present in requests

3. **CORS Errors**:
   - Verify CORS is configured for your frontend port
   - API should be running on port 5295

4. **File Upload Issues**:
   - Check Content-Type header in multipart requests
   - Ensure boundary is correctly specified

5. **User ID Issues**:
   - If using a placeholder `UserId` like `"admin@example.com"`, ensure it matches your Identity configuration
   - For production, use actual GUIDs from the `AspNetUsers` table

---

## Summary âœ…

You've successfully created:

âœ… **Paged Result Model**: Reusable pagination structure with navigation properties
âœ… **Transaction List Endpoint**: Clean, feature-organized endpoint for retrieving transactions
âœ… **Import Result Model**: Structured response model for import operations
âœ… **Transaction Import Endpoint**: File upload endpoint with validation (placeholder implementation)
âœ… **Anti-Forgery Filter**: Applied template's conditional protection for API key authentication
âœ… **API Key Configuration**: Proper setup for testing with static API keys
âœ… **Feature-Based Organization**: Properly structured API files following clean architecture
âœ… **API Registration**: Centralized endpoint registration with proper grouping and security filters
âœ… **API Testing Setup**: HTTP files for endpoint testing with proper authentication
âœ… **Error Handling**: Proper validation and error responses with TypedResults

**Next Step**: Move to [003-csv-import.md](003-csv-import.md) to implement the CSV parsing and storage functionality.